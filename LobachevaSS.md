# Инструкция по работе с Git и удаленными репозиториями

*Начинаем наше знакомство с контролем версий*

## Что такое git?
***

Git - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок - полезно для дизайнеров.

## Подготовка репозитория

Для создания репозитория неоьходимо выполнить команду *git init* в папке с репозиторием и у Вас создастся репозиторий (появится скрытая папка .git)
>
> Инициализируем репозиторий:
>> 
>> *git init*
>

## Создание коммитов
***


    Каждая точка сохранения вашего проекта носит название коммит (commit). У каждого commit-a есть hash (уникальный id) и комментарий. Из таких commit-ов собирается ветка.

### Git add


> Добавим все файлы проекта в нам будующий commit 
>> *git add* 
> 
> Или так
> 
>>  *git add --all*
> 
> Если хотим добавить конкретный файл то можно так
> > *git add <имя_файла>*
> 
> Теперь создаем commit.
> 
> Обязательно указываем комментарий. И не забываем про кавычки
> > git commit -m "<комментарий>"

### Просмотр состояние репозитория

Для того, чтобы посмотреть состояние репозитория, используется команда *git status*, которая пишется в папке с репозиторием, в итоге Вы увидите, были ли или нет какие-либо изменения в файлах.

## Основные команды работы с репозиторием
***
* git init (Инициализация репозитория)
* git add 'file' (Добавление файлов под версионный контроль)
  * git add . (Добавление всех файлов по версионный контроль)
* git commit (Фиксация изменений)
  * git commit -a -m "comment" (Игнорирование индексации)
  * git commit --amend (Изменение последнего коммита)
* git clone 'remote'
git clone 'remote' (Клонирование удаленного репозитория)
  * git clone 'remote' 'dir' (Клонирование удаленного репозитория в указанный каталог)
* git status (Определение состояния файлов)
* git diff (Просмотр изменных, но не проиндексированных файлов)
  * git diff --staged (Просмотр проиндексированных файлов, которые войдут в следующий коммит)
* git rm 'file' (Удаление файла с индексацией)
  * git rm --cached 'file' (Удаление файла из индекса (при этом файл остается в рабочем каталоге))
* git mv 'old file' 'new file' (Перемещение файлов)
* git log (Просмотр истории коммитов)
* git reset HEAD 'file' (Отмена индексации файла)
* git checkout -- 'file' (Отмена изменений файла)

## Последовательность начала работы
***
1. Инициировать репозиторий
2. Внести правки в файл или создать нужный файл
3. Добавить файл под версионный контроль
4. Зафиксировать изменения через коммит
   * -m : фиксируем изменения с комментарием
   * -am : фиксируем изменения с комментарием + аналог команде git add


## Ветки
***
Если посмотреть на картинку, то становиться чуть проще с пониманием. Каждый кружок, это **commit**. Стрелочки показывают направление, из какого **commit** сделан следующий. Например *C3* сделан из *С2* и т. д. Все эти **commit** находятся в ветке под названием **main**. Это основная ветка, чаще всего ее называют **master** . Прямоугольник **main** показывает в каком **commit** мы сейчас находимся, проще говоря указатель.

Все это может превратиться в более сложный граф, состоящий из нескольких веток, которые сливаются в одну.

***
![Картинка 3 веток](https://gauge.agency/wp-content/uploads/2016/10/workflow-illustration-1024x341.png "Картинка 3 веток")
***
## Как выполнить слияние веток?

Если Вы работаете в основной ветке master/main и Вам необходимо выполнить слияние с правками в параллельной ветке, которую делали Вы или Ваш коллега, то алгоритм следующий

> Переключаемся на другую ветку, одновременно создавая ее, данная команда объединяет команды "создать новую ветку1" и "перейти на новую созданную ветку1"
>> git checkout -b branch_name1
> 
> Выполняем все необходимые действия
> 
> Сохраняем правки в ветке1
> 
> Выполняем коммит в ветке1
> 
> Переключаемся в главную ветку
> 
>> git checkout master
> Выполняем слияние к главной ветке выбранной нами ветки с правками
> 
>> git merge branch_name1

Если необходимо выполнить слияние нескольких веток, то нужно в данной команде **git checkout** перечислить все ветки через пробел
> >> git merge branch_name1 branch_name2 branch_name3
***
**ВАЖНО!**
***
     Чем больше веток Вы объединяете, тем выше вероятность возникновения конфликтов, если в данных ветках работа велась с одними и теми же файлами.

## Работа с удалённым репозиторием
* *git remote* - отоброжение удалённых репозиториев
* *git remote add < alias > < remote >* - добавление удалённых репозиториев
* *git remote show < remote >* - информация об удалённом репозитории
* *git push < remote> < branch >* - отправление локальных изменений на удалённый сервис
* *git remote show < old name > < new name >* - переименновывание удалённых репозиториев
* *git pull < remote > < branch >* - получение данных из удалённого репозитория и слияние с локальным
* *git fetch < remote >* - получение данных из удалённых репозиториев
* *git remote rename < old name > < new name >* - переименовывание удалённых репозиториев
* *git remote rm < remote>* - удалёние удалённых репозиториев